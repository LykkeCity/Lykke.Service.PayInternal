using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Common.Log;
using JetBrains.Annotations;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Service.PayInternal.Core;
using Lykke.Service.PayInternal.Core.Domain.Transaction;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Exceptions;
using Lykke.Service.PayInternal.Core.Services;
using Lykke.Service.PayInternal.Services.Domain;

namespace Lykke.Service.PayInternal.Services
{
    [UsedImplicitly]
    public class TransferService : ITransferService
    {
        private readonly IBitcoinApiClient _bitcoinServiceClient;
        private readonly ITransferRepository _transferRepository;
        private readonly IBlockchainTransactionRepository _transactionRepository;
        private readonly ITransactionPublisher _transactionPublisher;
        private readonly ILog _log;

        public TransferService(IBitcoinApiClient bitcoinServiceClient,
            ITransferRepository transferRepository,
            IBlockchainTransactionRepository transactionRepository,
            ITransactionPublisher transactionPublisher,
            ILog log)
        {
            _bitcoinServiceClient =
                bitcoinServiceClient ?? throw new ArgumentNullException(nameof(bitcoinServiceClient));
            _transferRepository = 
                transferRepository ?? throw new ArgumentNullException(nameof(transferRepository));
            _transactionRepository =
                transactionRepository ?? throw new ArgumentNullException(nameof(transactionRepository));
            _transactionPublisher =
                transactionPublisher ?? throw new ArgumentNullException(nameof(transactionPublisher));
            _log = 
                log ?? throw new ArgumentNullException(nameof(log));
        }

        public async Task<string> ExecuteAsync(BtcTransfer transfer)
        {
            IEnumerable<ToOneAddress> sources = transfer.Sources
                .Where(x => x != null)
                .Select(x => new ToOneAddress(x.Address, x.Amount));
            
            OnchainResponse response = await _bitcoinServiceClient.TransactionMultipleTransfer(
                Guid.NewGuid(),
                transfer.DestAddress, 
                LykkeConstants.BitcoinAssetId, 
                transfer.FeeRate, 
                transfer.FixedFee, 
                sources);

            if (response.HasError)
                throw new TransferException(response.Error.Code, response.Error.Message);

            return response.Transaction?.TransactionId?.ToString();
        }

        public async Task<MultipartTransferResponse> ExecuteMultipartTransferAsync(IMultipartTransfer multipartTransfer)
        {
            var transferRequest = multipartTransfer as MultipartTransfer;
            if (transferRequest == null)
                return new MultipartTransferResponse
                {
                    ErrorMessage = "Technical problem: could not obtain the request data in appropriate format.",
                    State = TransferExecutionResult.Fail
                };

            var response = new MultipartTransferResponse();

            await _transferRepository.AddAsync(multipartTransfer);

            foreach (var part in transferRequest.Parts)
            {
                var sources = part.Sources
                    .Where((x => x != null))
                    .Select((x => new ToOneAddress(x.Address, x.Amount)));

                var responseForPart = await _bitcoinServiceClient.TransactionMultipleTransfer(
                    Guid.NewGuid(),
                    part.Destination.Address,
                    multipartTransfer.AssetId,
                    multipartTransfer.FeeRate,
                    multipartTransfer.FixedFee,
                    sources);

                if (responseForPart.HasError)
                {
                    response.State = response.TransactionIdList.Count > 0 ? TransferExecutionResult.SuccessInPart : TransferExecutionResult.Fail;
                    response.ErrorMessage = $"Transfer execution failed. " + 
                                            $"Code = {responseForPart.Error.Code}, Message = {responseForPart.Error.Message}.";

                    await _log.WriteWarningAsync(nameof(TransferService),
                        nameof(ExecuteMultipartTransferAsync),
                        response.ErrorMessage);

                    break;
                }

                var blockchainTransaction = new BlockchainTransaction
                {
                    PaymentRequestId = multipartTransfer.PaymentRequestId,
                    Amount = part.Destination.Amount,
                    AssetId = multipartTransfer.AssetId,
                    Confirmations = 0,
                    Id = responseForPart.Transaction.TransactionId?.ToString(),
                    WalletAddress = part.Destination.Address
                };

                await _transactionRepository.AddAsync(blockchainTransaction);
                await _transactionPublisher.PublishAsync(blockchainTransaction);
                response.TransactionIdList.Add(responseForPart.Transaction.TransactionId.ToString());
            }

            response.State = TransferExecutionResult.Success;
            return response;
        }
    }
}
