using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Common.Log;
using JetBrains.Annotations;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Service.PayInternal.Core;
using Lykke.Service.PayInternal.Core.Domain.Transaction;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Exceptions;
using Lykke.Service.PayInternal.Core.Services;
using Lykke.Service.PayInternal.Core.Settings.ServiceSettings;
using Lykke.Service.PayInternal.Services.Domain;

namespace Lykke.Service.PayInternal.Services
{
    [UsedImplicitly]
    public class BtcTransferService : IBtcTransferService
    {
        private readonly IBitcoinApiClient _bitcoinServiceClient;
        private readonly ITransferRepository _transferRepository;
        private readonly ITransactionsService _transactionService;
        private readonly ITransactionPublisher _transactionPublisher;
        private readonly ExpirationPeriodsSettings _expirationPeriods;
        private readonly ILog _log;

        private const int SatoshiInBtc = 100000000;

        public BtcTransferService(IBitcoinApiClient bitcoinServiceClient,
            ITransferRepository transferRepository,
            ITransactionsService transactionServicey,
            ITransactionPublisher transactionPublisher,
            ExpirationPeriodsSettings expirationPeriods,
            ILog log)
        {
            _bitcoinServiceClient =
                bitcoinServiceClient ?? throw new ArgumentNullException(nameof(bitcoinServiceClient));
            _transferRepository = 
                transferRepository ?? throw new ArgumentNullException(nameof(transferRepository));
            _transactionService =
                transactionServicey ?? throw new ArgumentNullException(nameof(transactionServicey));
            _transactionPublisher =
                transactionPublisher ?? throw new ArgumentNullException(nameof(transactionPublisher));
            _expirationPeriods =
                expirationPeriods ?? throw new ArgumentNullException(nameof(expirationPeriods));
            _log = 
                log ?? throw new ArgumentNullException(nameof(log));
        }

        public async Task<string> ExecuteAsync(BtcTransfer transfer)
        {
            IEnumerable<ToOneAddress> sources = transfer.Sources
                .Where(x => x != null)
                .Select(x => new ToOneAddress(x.Address, x.Amount));
            
            OnchainResponse response = await _bitcoinServiceClient.TransactionMultipleTransfer(
                Guid.NewGuid(),
                transfer.DestAddress, 
                LykkeConstants.BitcoinAssetId, 
                transfer.FeeRate, 
                transfer.FixedFee, 
                sources);

            if (response.HasError)
                throw new TransferException(response.Error.Code, response.Error.Message);

            return response.Transaction?.TransactionId?.ToString();
        }

        //todo: it is common service and shodn't know anything about domain, remove transactionsType
        public async Task<MultipartTransferResponse> ExecuteMultipartTransferAsync(IMultipartTransfer multipartTransfer, TransactionType transactionsType)
        {
            if (!(multipartTransfer is MultipartTransfer transferRequest))
                return new MultipartTransferResponse
                {
                    ErrorMessage = "Technical problem: could not obtain the request data in appropriate format.",
                    State = TransferExecutionResult.Fail
                };

            var response = new MultipartTransferResponse
            {
                State = TransferExecutionResult.Success // Assume by default, but may be overriden in process.
            };

            if (string.IsNullOrWhiteSpace(multipartTransfer.TransferId))
                multipartTransfer.TransferId = Guid.NewGuid().ToString();

            await _transferRepository.AddAsync(multipartTransfer);

            // Preparing DueDate value depending on transaction type.
            DateTime? dueDate = null;

            switch (transactionsType)
            {
                case TransactionType.Payment:
                    break; // No need to set DueDate manually
                case TransactionType.Refund:
                    // Refund transaction gets expiration date based on transfer's creation date,
                    // wich is dependent on refund creation date
                    dueDate = multipartTransfer.CreationDate.Add(_expirationPeriods.Refund);
                    break;
                case TransactionType.Settlement:
                    break; // TODO: add some logic here
            }

            foreach (var part in transferRequest.Parts)
            {
                // todo: Satoshi to btc
                var sources = part.Sources
                    .Where(x => x != null)
                    .Select(x => new ToOneAddress(x.Address, x.Amount / SatoshiInBtc))
                    .ToList();

                var responseForPart = await _bitcoinServiceClient.TransactionMultipleTransfer(
                    Guid.NewGuid(),
                    part.Destination.Address,
                    multipartTransfer.AssetId,
                    multipartTransfer.FeeRate,
                    multipartTransfer.FixedFee,
                    sources);

                if (responseForPart.HasError)
                {
                    response.State = response.TransactionIdList.Count > 0 ? TransferExecutionResult.SuccessInPart : TransferExecutionResult.Fail;
                    response.ErrorMessage = $"Transfer execution failed. " + 
                                            $"Code = {responseForPart.Error?.Code}, Message = {responseForPart.Error?.Message}.";

                    await _log.WriteWarningAsync(nameof(BtcTransferService),
                        nameof(ExecuteMultipartTransferAsync),
                        response.ErrorMessage);
                
                    break;
                }

                //todo: transfer has to be thought throw, WalletAddress = source.Address is true only for refund transactions
                foreach (ToOneAddress source in sources)
                {
                    //_transactionService is a part of domain logic can't be part of transfer service
                    var blockchainTransaction = await _transactionService.CreateTransaction(new CreateTransaction
                    {
                        // todo: Satoshi to btc
                        Amount = (source.Amount ?? 0) / SatoshiInBtc,
                        AssetId = multipartTransfer.AssetId,
                        Confirmations = 0,
                        TransactionId = responseForPart.Transaction.Hash,
                        WalletAddress = source.Address,
                        Type = transactionsType,
                        Blockchain = BlockchainType.Bitcoin.ToString(),
                        FirstSeen = null,
                        DueDate = dueDate
                    });

                    await _transactionPublisher.PublishAsync(blockchainTransaction);

                    response.TransactionIdList.Add(blockchainTransaction.Id);
                }
            }

            return response;
        }
    }
}
