using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Common.Log;
using JetBrains.Annotations;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Common.Log;
using Lykke.Service.BlockchainWallets.Client;
using Lykke.Service.BlockchainWallets.Contract;
using Lykke.Service.BlockchainWallets.Contract.Models;
using Lykke.Service.PayInternal.Core;
using Lykke.Service.PayInternal.Core.Domain;
using Lykke.Service.PayInternal.Core.Domain.Transaction;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Exceptions;
using Lykke.Service.PayInternal.Core.Services;
using NBitcoin;
using QBitNinja.Client;
using QBitNinja.Client.Models;

namespace Lykke.Service.PayInternal.Services
{
    public class BitcoinApiClient : IBlockchainApiClient
    {
        private readonly IBitcoinApiClient _bitcoinServiceClient;
        private readonly IFeeProvider _feeProvider;
        private readonly Network _bitcoinNetwork;
        private readonly QBitNinjaClient _qBitNinjaClient;
        private readonly IBlockchainWalletsClient _blockchainWalletsClient;
        private readonly string _lykkeWalletClientId;
        private readonly bool _bilTransitionPeriodEnabled;
        private readonly ILog _log;

        public BitcoinApiClient(
            [NotNull] IBitcoinApiClient bitcoinServiceClient,
            [NotNull] IFeeProvider feeProvider,
            [NotNull] QBitNinjaClient qBitNinjaClient,
            [NotNull] ILogFactory logFactory,
            [NotNull] string bitcoinNetwork,
            [NotNull] IBlockchainWalletsClient blockchainWalletsClient,
            [NotNull] string lykkeWalletClientId, 
            bool bilTransitionPeriodEnabled)
        {
            _bitcoinServiceClient =
                bitcoinServiceClient ?? throw new ArgumentNullException(nameof(bitcoinServiceClient));
            _feeProvider = feeProvider ?? throw new ArgumentNullException(nameof(feeProvider));
            _qBitNinjaClient = qBitNinjaClient ?? throw new ArgumentNullException(nameof(qBitNinjaClient));
            _blockchainWalletsClient = blockchainWalletsClient ?? throw new ArgumentNullException(nameof(blockchainWalletsClient));
            _log = logFactory.CreateLog(this);
            _bitcoinNetwork = Network.GetNetwork(bitcoinNetwork);
            _lykkeWalletClientId = lykkeWalletClientId;
            _bilTransitionPeriodEnabled = bilTransitionPeriodEnabled;
        }

        public async Task<BlockchainTransferResult> TransferAsync(BlockchainTransferCommand transfer)
        {
            BlockchainTransferResult result = new BlockchainTransferResult {Blockchain = BlockchainType.Bitcoin};

            foreach (var transferAmountGroup in transfer.Amounts.GroupBy(x => x.Destination))
            {
                string destination = transferAmountGroup.Key;

                var sources = transferAmountGroup.Select(x =>
                {
                    switch (transfer.AssetId)
                    {
                        case LykkeConstants.BitcoinAsset: 
                            return new ToOneAddress(x.Source, x.Amount);
                        case LykkeConstants.SatoshiAsset:
                            return new ToOneAddress(x.Source, x.Amount?.SatoshiToBtc());
                        default: 
                            throw new AssetNotSupportedException(transfer.AssetId);
                    }
                }).ToList();

                //todo: must be moved to BIL
                OnchainResponse response = await _bitcoinServiceClient.TransactionMultipleTransfer(
                    Guid.NewGuid(),
                    destination,
                    LykkeConstants.BitcoinAsset,
                    _feeProvider.FeeRate,
                    _feeProvider.FixedFee,
                    sources);

                var errorMessage = response.HasError
                    ? $"Error placing MultipleTransfer transaction to destination address = {transferAmountGroup.Key}, code = {response.Error?.Code}, message = {response.Error?.Message}"
                    : string.Empty;

                result.Transactions.Add(new BlockchainTransactionResult
                {
                    Amount = sources.Sum(x => x.Amount ?? 0),
                    AssetId = LykkeConstants.BitcoinAsset,
                    Hash = response.Transaction?.Hash,
                    IdentityType = TransactionIdentityType.Hash,
                    Identity = response.Transaction?.Hash,
                    Sources = sources.Select(x => x.Address),
                    Destinations = new List<string> {destination},
                    Error = errorMessage
                });
            }

            return result;
        }

        public async Task<string> CreateAddressAsync()
        {
            try
            {
                BlockchainWalletResponse walletResponse = await _blockchainWalletsClient.CreateWalletAsync(
                    BlockchainType.Bitcoin.ToString(),
                    Guid.Parse(_lykkeWalletClientId),
                    CreatorType.LykkePay);

                return walletResponse.Address;
            }
            catch (ErrorResponseException e)
            {
                _log.ErrorWithDetails(e,
                    new
                    {
                        e.StatusCode, 
                        ErrorType = e.Error?.ErrorCode.ToString(),
                        e.Error?.ErrorMessage
                    });

                throw new WalletAddressAllocationException(BlockchainType.Bitcoin);
            }
        }

        public async Task<bool> DeleteAddressAsync(string address)
        {
            try
            {
                return await _blockchainWalletsClient.DeleteWalletAsync(
                    BlockchainType.Bitcoin.ToString(),
                    Guid.Parse(_lykkeWalletClientId), 
                    address);
            }
            catch (ErrorResponseException e)
            {
                _log.ErrorWithDetails(e,
                    new
                    {
                        e.StatusCode,
                        ErrorType = e.Error?.ErrorCode.ToString(),
                        e.Error?.ErrorMessage
                    });

                return _bilTransitionPeriodEnabled && e.StatusCode == HttpStatusCode.NotFound;
            }
        }

        public Task<bool> ValidateAddressAsync(string address)
        {
            try
            {
                _bitcoinNetwork.Parse(address);
            }
            catch (Exception)
            {
                return Task.FromResult(false);
            }

            return Task.FromResult(true);
        }

        public async Task<IReadOnlyList<BlockchainBalanceResult>> GetBalancesAsync(string address)
        {
            var balanceResult = new BlockchainBalanceResult
            {
                AssetId = LykkeConstants.BitcoinAsset,
                Balance = 0
            };

            try
            {
                BalanceSummary balanceSummary =
                    await _qBitNinjaClient.GetBalanceSummary(BitcoinAddress.Create(address, _bitcoinNetwork));

                balanceResult.Balance = balanceSummary?.Spendable?.Amount?.ToDecimal(MoneyUnit.BTC) ?? 0;
            }
            catch (Exception e)
            {
                _log.ErrorWithDetails(e, new {address});
            }

            return new List<BlockchainBalanceResult> {balanceResult};
        }
    }
}
