using Common;
using Common.Log;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Domain.Wallet;
using Lykke.Service.PayInternal.Core.Services;
using Lykke.Service.PayInternal.Services.Domain;
using System;
using System.Linq;
using System.Threading.Tasks;


namespace Lykke.Service.PayInternal.Services
{
    public class BtcTransferRequestService : ITransferRequestService
    {

        private readonly ITransferRequestRepository _transferRequestRepository;
        private readonly IWalletRepository _walletRepository;
        private readonly IBitcoinApiClient _bitcointApiClient;
        private readonly ITransferRequestPublisher _transferRequestPublisher;
        private readonly ILog _log;


        #region .ctors
        public BtcTransferRequestService(
            ITransferRequestRepository transferRequestRepository,
            IWalletRepository walletRepository,
            IBitcoinApiClient bitcointApiClient,
            ITransferRequestPublisher transferRequestPublisher,
            ILog log)
        {
            _transferRequestRepository = transferRequestRepository ?? throw new ArgumentNullException(nameof(transferRequestRepository));
            _walletRepository = walletRepository ?? throw new ArgumentNullException(nameof(walletRepository));
            _bitcointApiClient = bitcointApiClient ?? throw new ArgumentNullException(nameof(bitcointApiClient));
            _transferRequestPublisher = transferRequestPublisher ?? throw new ArgumentNullException(nameof(transferRequestPublisher));
            _log = log ?? throw new ArgumentNullException(nameof(log));
        }
        #endregion

        #region public

        /// <summary>
        /// Tries to execute a crosswise transfer request from many sources to many destinations.
        /// </summary>
        /// <param name="transferRequest">The transfer request.</param>
        /// <returns>The updated transfer request OR transfer request with error.</returns>
        public async Task<ITransferRequest> CreateTransferCrosswiseAsync(ITransferRequest transferRequest)
        {
            // We need an independent copy of the request here, for some methods in current implementation change the inner state of the given object.
            // For instance, the BtcTransferRequest class' constructor reuses the transaction list it gets.
            var transferRequestUpdated = transferRequest.DeepCopy();

            // First of all, we need to verify the source addresses to belong to the Merchant.
            var sourcesCheckupResult = await CheckupSourcesAndWalletsAsync(transferRequestUpdated);
            if (sourcesCheckupResult != null)
                return sourcesCheckupResult;

            // Here would be no additional validations. If transaction fails, we will know it from the underlying BitcoinApi service.

            // Save the initial state of transfer
            await _transferRequestRepository.SaveAsync(transferRequestUpdated);
            await _transferRequestPublisher.PublishAsync(transferRequestUpdated);

            // The main work
            foreach (var tran in transferRequestUpdated.TransactionRequests)
            {
                var sourceAddresses = (from s in tran.SourceAmounts
                                       select new ToOneAddress(s.Address, s.Amount)).ToList();
                // Please, note: feeRate = 0 and fixedFee = 0 here
                var currentResult = await _bitcointApiClient.TransactionMultipleTransfer(null, tran.DestinationAddress, tran.AssetId, 0, 0, sourceAddresses);

                if (currentResult == null || currentResult.HasError)
                {
                    // Please, note: after the first faulty transaction we abort the further execution.
                    // BUT money that we had already transfered will not go back to source address(es).
                    // To make the whole transfer request atomic we need to implement such feature in
                    // BitcoinApi service at first.
                    return await PackFaultyResult(currentResult, tran, transferRequestUpdated);
                }

                tran.TransactionHash = currentResult.Transaction.Hash;
                
                await _transferRequestRepository.SaveAsync(transferRequestUpdated);
                await _transferRequestPublisher.PublishAsync(transferRequestUpdated);
            }

            transferRequestUpdated.TransferStatus = TransferStatus.InProgress;
            transferRequestUpdated.TransferStatusError = TransferStatusError.None;
            await _transferRequestRepository.SaveAsync(transferRequestUpdated);
            await _transferRequestPublisher.PublishAsync(transferRequestUpdated);
            return transferRequestUpdated;
        }

        public async Task<ITransferRequest> UpdateTransferStatusAsync(ITransferRequest transfer)
        {
            var storedTransfer = await GetTransferInfoAsync(transfer.TransferId);
            if (storedTransfer == null)
            {
                return null;
            }
            storedTransfer.TransferStatus = transfer.TransferStatus;
            storedTransfer.TransferStatusError = transfer.TransferStatusError;

            try
            {
                await _transferRequestRepository.SaveAsync(storedTransfer);
                await _transferRequestPublisher.PublishAsync(storedTransfer);
                await _log.WriteInfoAsync(nameof(BtcTransferRequestService), nameof(UpdateTransferStatusAsync),
                    storedTransfer.ToJson(),
                    "Transfer with ID = " + storedTransfer.TransferId + " was updated");

                return storedTransfer;
            }
            catch (Exception e)
            {
                var failedResult = BtcTransferRequest.CreateErrorTransferRequest(transfer.MerchantId,
                    TransferStatusError.InternalError, transfer.TransactionRequests);
                await _transferRequestPublisher.PublishAsync(failedResult);
                await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(UpdateTransferStatusAsync),
                    failedResult.ToJson(),
                    "Can not update transfer state: " + e.Message);

                return failedResult;
            }
        }
        
        public async Task<ITransferRequest> UpdateTransferAsync(ITransferRequest transfer)
        {
            try
            {
                await _transferRequestRepository.SaveAsync(transfer);
                await _transferRequestPublisher.PublishAsync(transfer);
                await _log.WriteInfoAsync(nameof(BtcTransferRequestService), nameof(UpdateTransferStatusAsync),
                    transfer.ToJson(),
                    "Transfer with ID = " + transfer.TransferId + " was updated");

                return transfer;
            }
            catch (Exception e)
            {
                var failedResult = BtcTransferRequest.CreateErrorTransferRequest(transfer.MerchantId,
                    TransferStatusError.InternalError, transfer.TransactionRequests);
                await _transferRequestPublisher.PublishAsync(failedResult);
                await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(UpdateTransferStatusAsync),
                    failedResult.ToJson(),
                    "Can not update transfer: " + e.Message);

                return failedResult;
            }
        }

        public async Task<ITransferRequest> GetTransferInfoAsync(string transferId)
        {
            return await _transferRequestRepository.GetAsync(transferId);
        }

        #endregion

        #region private

        /// <summary>
        /// Looks through the source addresses and check em up to belong to the Merchant.
        /// </summary>
        /// <param name="transferRequest">Transfer request.</param>
        /// <returns>Error transfer request OR null if validation ended up with success.</returns>
        private async Task<ITransferRequest> CheckupSourcesAndWalletsAsync(ITransferRequest transferRequest)
        {
            // Not the very best algorythm for different transactions may have the same source address(es).
            var wallets = (await _walletRepository.GetByMerchantAsync(transferRequest.MerchantId))?.ToList();
            if (wallets == null)
            {
                await _log.WriteWarningAsync(
                            nameof(BtcTransferRequestService),
                            nameof(CreateTransferCrosswiseAsync),
                            transferRequest.ToJson(),
                            $"Error while creating transfer: the merchant with ID \"{transferRequest.MerchantId}\" does not exist.");

                return BtcTransferRequest.CreateErrorTransferRequest(
                    transferRequest.MerchantId,
                    TransferStatusError.MerchantNotFound,
                    transferRequest.TransactionRequests);
            }
            if (!wallets.Any())
            {
                await _log.WriteWarningAsync(
                            nameof(BtcTransferRequestService),
                            nameof(CreateTransferCrosswiseAsync),
                            transferRequest.ToJson(),
                            $"Error while creating transfer: the merchant with ID \"{transferRequest.MerchantId}\" does not have any wallets.");

                return BtcTransferRequest.CreateErrorTransferRequest(
                    transferRequest.MerchantId,
                    TransferStatusError.MerchantHasNoWallets,
                    transferRequest.TransactionRequests);
            }

            foreach (var tran in transferRequest.TransactionRequests)
            {
                foreach (var item in tran.SourceAmounts)
                {
                    if (!wallets.Any(w => w.Address == item.Address))
                    {
                        await _log.WriteWarningAsync(
                            nameof(BtcTransferRequestService),
                            nameof(CreateTransferCrosswiseAsync),
                            transferRequest.ToJson(),
                            $"Error while creating transfer: the source address \"{item.Address}\" is incorrect or does not belong to Merchant with ID = \"{transferRequest.MerchantId}\"");

                        return BtcTransferRequest.CreateErrorTransferRequest(
                            transferRequest.MerchantId,
                            TransferStatusError.InvalidAddress,
                            transferRequest.TransactionRequests);

                    }
                }
            }

            return null; // Everything's fine
        }

        /// <summary>
        /// Packs the result of faulty transaction into new transfer request object, supplying the error info for clients.
        /// </summary>
        /// <param name="btcApiResponce">The response of Bitcoin Api Service on the task of transaction execution.</param>
        /// <param name="faultyTransaction">The faulty transaction itself.</param>
        /// <param name="theTransfer">The transfer request from wich everything had started.</param>
        /// <returns></returns>
        private async Task<ITransferRequest> PackFaultyResult(OnchainResponse btcApiResponce, ITransactionRequest faultyTransaction, ITransferRequest theTransfer)
        {
            var errMessage = btcApiResponce?.Error?.Message ?? $"Transaction to destination address \"{faultyTransaction.DestinationAddress}\" with amount of \"{faultyTransaction.Amount} {faultyTransaction.AssetId}\" failed by unknown reason.";
            var errCode = btcApiResponce?.Error?.Code;

            await _log.WriteWarningAsync(
                nameof(BtcTransferRequestService),
                nameof(CreateTransferCrosswiseAsync),
                faultyTransaction.ToJson(),
                $"Transaction to destination address \"{faultyTransaction.DestinationAddress}\" with amount of \"{faultyTransaction.Amount} {faultyTransaction.AssetId}\" failed with code {errCode} and message \"{errMessage}\".");
            
            return BtcTransferRequest.CreateErrorTransferRequest(
                theTransfer.MerchantId,
                TransferStatusError.InternalError,
                theTransfer.TransactionRequests);
        }
        
        #endregion
    }
}
