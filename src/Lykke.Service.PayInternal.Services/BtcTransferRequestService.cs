using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Common.Log;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Domain.Wallet;
using Lykke.Service.PayInternal.Core.Services;
using Lykke.Service.PayInternal.Services.Domain;
using NBitcoin;
using Newtonsoft.Json;
using QBitNinja.Client;

namespace Lykke.Service.PayInternal.Services
{
    public class BtcTransferRequestService : ITransferRequestService
    {
        private const string BitcoinAssert = "BTC";
        private readonly ITransferRepository _transferRepository;
        private readonly IWalletRepository _walletRepository;
        private readonly IBitcoinApiClient _bitcointApiClient;
        private readonly ILog _log;

        #region .ctors
        public BtcTransferRequestService(
            ITransferRepository transferRepository,
            IWalletRepository walletRepository,
            IBitcoinApiClient bitcointApiClient,
            QBitNinjaClient ninjaClient,
            ILog log)
        {
            _transferRepository = transferRepository ?? throw new ArgumentNullException(nameof(transferRepository));
            _walletRepository = walletRepository ?? throw new ArgumentNullException(nameof(walletRepository));
            _bitcointApiClient = bitcointApiClient ?? throw new ArgumentNullException(nameof(bitcointApiClient));
            _log = log ?? throw new ArgumentNullException(nameof(log));
        }
        #endregion
        #region public
        public async Task<ITransfer> CreateTransferAsync(ITransferRequest transferRequest)
        {
            var wallets = (await _walletRepository.GetByMerchantAsync(transferRequest.MerchantId)).ToList();

            var sources = CalculateSources(
                from w in wallets
                select new SourceAmount
                {
                    SourceAddress = w.Address,
                    Amount = 0
                }, transferRequest.Amount, wallets);
            if (sources == null)
            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAmount,
                    DestinationAddress = transferRequest.DestinationAddress,
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }
            var transferWallets = new List<string>(sources.Select(s => s.SourceAddress))
            {
                transferRequest.DestinationAddress
            };

            var isAddressesValid = CheckAddressesValid(transferWallets);
            if (!isAddressesValid)
            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAddress,
                    DestinationAddress = transferRequest.DestinationAddress,
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }
            return await CreateBtcTransfer(sources, transferRequest.DestinationAddress);
        }

        public async Task<ITransfer> CreateTransferAsync(ISourcesTransferRequest transferRequest)
        {
            var wallets = (await _walletRepository.GetByMerchantAsync(transferRequest.MerchantId)).ToList();


            var sources = CalculateSources(transferRequest.SourceAddresses, transferRequest.Amount, wallets);
            if (sources == null)
            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAmount,
                    DestinationAddress = transferRequest.DestinationAddress,
                    SourceAddresses = transferRequest.SourceAddresses,
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }
            var transferWallets = new List<string>(sources.Select(s => s.SourceAddress))
            {
                transferRequest.DestinationAddress
            };

            var isAddressesValid = CheckAddressesValid(transferWallets);
            if (!isAddressesValid)
            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAddress,
                    DestinationAddress = transferRequest.DestinationAddress,
                    SourceAddresses = transferRequest.SourceAddresses,
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }

            return await CreateBtcTransfer(sources, transferRequest.DestinationAddress);
        }

        public async Task<ITransfer> CreateTransferAsync(ISingleSourceTransferRequest transferRequest)
        {
            var wallets = (await _walletRepository.GetByMerchantAsync(transferRequest.MerchantId)).ToList();
            if (wallets.FirstOrDefault(w => w.Address.Equals(transferRequest.SourceAddress) &&
                                            w.Amount >= transferRequest.Amount) == null)

            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAmount,
                    DestinationAddress = transferRequest.DestinationAddress,
                    SourceAddresses = new[] { new SourceAmount { SourceAddress = transferRequest.SourceAddress, Amount = transferRequest.Amount } },
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }
            var sources = new List<ISourceAmount>
            {
                new SourceAmount
                {
                    SourceAddress = transferRequest.SourceAddress,
                    Amount = transferRequest.Amount
                }
            };
            var isAddressesValid = CheckAddressesValid(new[]
                {transferRequest.SourceAddress, transferRequest.DestinationAddress});
            if (!isAddressesValid)
            {
                return new TransferDto
                {
                    TransferStatus = TransferStatus.Error,
                    TransferStatusError = TransferStatusError.InvalidAddress,
                    DestinationAddress = transferRequest.DestinationAddress,
                    SourceAddresses = new[] { new SourceAmount { SourceAddress = transferRequest.SourceAddress, Amount = transferRequest.Amount } },
                    Amount = transferRequest.Amount,
                    Currency = BitcoinAssert
                };
            }
            return await CreateBtcTransfer(sources, transferRequest.DestinationAddress);
        }

        public async Task<ITransfer> UpdateTransferStatusAsync(ITransfer transfer)
        {
            var t = await GetTransferInfoAsync(transfer);
            if (t == null)
            {
                return null;
            }
            t.TransferStatus = transfer.TransferStatus;
            t.TransferStatusError = transfer.TransferStatusError;
            return await _transferRepository.SaveAsync(t);
        }



        public async Task<ITransfer> UpdateTransferAsync(ITransferInfo transfer)
        {
            return await _transferRepository.SaveAsync(transfer);
        }

        public async Task<ITransferInfo> GetTransferInfoAsync(ITransfer transfer)
        {
            return await _transferRepository.GetAsync(transfer.TransferId, transfer.TransactionHash);
        }
        #endregion
        #region private

        private async Task<ITransferInfo> CreateBtcTransfer(List<ISourceAmount> sources, string destination)
        {
            sources = sources.Where(s=>s.Amount != 0).ToList();
            OnchainResponse request = null;
            var result = new TransferDto
            {
                DestinationAddress = destination,
                Amount = sources.Sum(s => s.Amount),
                Currency = BitcoinAssert,
                SourceAddresses = sources,
                TransferStatus = TransferStatus.InProgress,
                TransferStatusError = TransferStatusError.NotError
            };

            var store = new MultipleTransferRequest
            {
                Asset = BitcoinAssert,
                Destination = destination,
                Sources = (from s in sources
                    select new ToOneAddress(s.SourceAddress, s.Amount)).ToList()
            };

            if (sources.Count != 0)
            {
                request = await _bitcointApiClient.TransactionMultipleTransfer(null, store.Destination, store.Asset, 0, 0, store.Sources);
            }
           
          
            if (request == null || request.HasError)
            {
               
                if (request != null && request.Error.Code == "3")
                {
                    var errorCode = request.Error.Code;
                    var errorMessage = request.Error.Message;
                    await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(store), $"Invalid amount. Error on TransactionMultipletransfer: {errorMessage} ({errorCode})");
                    result.TransferStatus = TransferStatus.Error;
                    result.TransferStatusError = TransferStatusError.InvalidAmount;
                    if (await _transferRepository.SaveAsync(result) == null)
                    {
                        result.TransferStatusError = TransferStatusError.InternalError;
                    }
                    return result;
                }

                await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(store), "Transaction not confirmed.");

                await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(store), "Transaction not confirmed.");
                result.TransferStatus = TransferStatus.Error;
                result.TransferStatusError = TransferStatusError.NotConfirmed;
                if (await _transferRepository.SaveAsync(result) == null)
                {
                    result.TransferStatusError = TransferStatusError.InternalError;
                }
                return result;
            }

            result.TransactionHash = request.Transaction.Hash;
            await _log.WriteInfoAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(result), "Transfer created");

            return result;

        }

        private List<ISourceAmount> CalculateSources(IEnumerable<ISourceAmount> sources, decimal amount, List<IWallet> wallets)
        {
            var result = new List<ISourceAmount>();
            var sourcesList = sources?.ToList() ?? new List<ISourceAmount>();
            var sourceToCalc = new List<ISourceAmount>();
            if (sourcesList.Count == 0)
            {
                sourceToCalc.AddRange(from w in wallets
                    select new SourceAmount { SourceAddress = w.Address, Amount = w.Amount });
            }
            else if (sourcesList.All(s => s.Amount == 0))
            {
                sourceToCalc.AddRange(from s in sourcesList
                    join w in wallets on s.SourceAddress equals w.Address
                    select new SourceAmount { SourceAddress = s.SourceAddress, Amount = w.Amount });
            }
            else
            {
                sourceToCalc.AddRange(from s in sourcesList
                    join w in wallets on s.SourceAddress equals w.Address
                    where s.Amount <= w.Amount
                    select new SourceAmount { SourceAddress = s.SourceAddress, Amount = w.Amount });
                if (result.Count != sourcesList.Count)
                {
                    result.Clear();
                }
            }

            if (amount == 0)
            {
                result = sourceToCalc;
            }
            else
            {
                var amounToPay = amount;
                while (amounToPay > 0)
                {
                    var sourceAmount = sourceToCalc.FirstOrDefault();
                    if (sourceAmount == null)
                    {
                        return null;
                    }
                    if (amounToPay > sourceAmount.Amount)
                    {
                        amounToPay -= sourceAmount.Amount;
                    }
                    else
                    {
                        sourceAmount.Amount = amounToPay;
                        amounToPay = 0;
                    }
                    result.Add(sourceAmount);
                    sourceToCalc.Remove(sourceAmount);
                }
            }

            return result.Count == 0 ? null : result;
        }

        private bool CheckAddressesValid(IReadOnlyList<string> addresses)
        {
            try
            {
                foreach (var address in addresses)
                {
                    BitcoinAddress.Create(address);
                }
                return true;
            }
            catch
            {
                return false;
            }

        }
        #endregion
    }
}
